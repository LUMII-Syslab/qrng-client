import java.nio.file.Files

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
    }
}

plugins {
    id 'java-library'
    id 'org.graalvm.buildtools.native' version '0.9.24'
    id "de.undercouch.download" version "5.6.0"
//    id 'org.ajoberstar.grgit' version '5.2.1' // Add the GrGit plugin
}


repositories {
    mavenCentral()
}


tasks.register("prerequisites") {
    doFirst {
        def directory = new File('src/tls-injection-mechanism')
        def cloned_dir = new File('../tls-injection-mechanism')
        def cloned_relative_dir = new File('../../tls-injection-mechanism')
        if (!directory.exists()) {
            // cloning...
            if (!cloned_dir.exists()) {
                exec {
                    workingDir '..'
                    commandLine 'git', 'clone', 'https://github.com/LUMII-Syslab/tls-injection-mechanism.git'
                }
                exec {
                    workingDir cloned_dir
                    commandLine 'git', 'checkout', 'tls-injection2'
                }
            }
            // symlink...
            Files.createSymbolicLink(directory.toPath(), cloned_relative_dir.toPath())
        }

        directory = new File('src/tls-injection-pqc')
        cloned_dir = new File('../tls-injection-pqc')
        cloned_relative_dir = new File('../../tls-injection-pqc')
        if (!directory.exists()) {
            // cloning...
            if (!cloned_dir.exists()) {
                exec {
                    workingDir '..'
                    commandLine 'git', 'clone', 'https://github.com/LUMII-Syslab/tls-injection-pqc.git'
                }
            }
            // symlink...
            Files.createSymbolicLink(directory.toPath(), cloned_relative_dir.toPath())
        }

        download.run {
            src ([
                    "https://qkd.lumii.lv/liboqs-binaries/Linux-x86_64/liboqs.so",
                    "https://qkd.lumii.lv/liboqs-binaries/Linux-x86_64/liboqs-jni.so"
            ])
            dest "lib"
            overwrite true
        }
        exec {
            workingDir 'lib'
            commandLine '/usr/bin/bash', '-c', 'chmod +x *.so'
        }


        directory = new File('src/tls-injection-smartcard')
        cloned_dir = new File('../tls-injection-smartcard')
        cloned_relative_dir = new File('../../tls-injection-smartcard')
        if (!directory.exists()) {
            // cloning...
            if (!cloned_dir.exists()) {
                exec {
                    workingDir '..'
                    commandLine 'git', 'clone', 'https://github.com/LUMII-Syslab/tls-injection-smartcard.git'
                }
            }
            // symlink...
            Files.createSymbolicLink(directory.toPath(), cloned_relative_dir.toPath())
        }

    }
}
build.dependsOn(prerequisites)

sourceSets.main {
    java {
        srcDirs 'src/main/java',
                'src/tls-injection-mechanism/core/src/main/java',
                'src/tls-injection-mechanism/pkix/src/main/java',
                'src/tls-injection-mechanism/prov/src/main/java',
                'src/tls-injection-mechanism/tls/src/main/java',
                'src/tls-injection-mechanism/tls/src/main/jdk1.9/org/bouncycastle/jsse/provider',
                // ^^^ important that we do not include module-info.java (otherwise, the whole BC module farm is needed)
                // ^^^ and org/bouncycastle/tls/crypto/impl/jcajce/** (otherwise, there are duplicate class files)
                'src/tls-injection-mechanism/util/src/main/java',

                'src/tls-injection-pqc/src/main/java',
                'src/tls-injection-smartcard/src/main/java'
    }
}


compileJava.options.encoding = "UTF-8"

configurations {

    nativeLibraryAndJars { // dll + all jars
        canBeConsumed = false
        canBeResolved = true
        extendsFrom compileOnly
    }
    nativeLibraryOnly { // only dll, without any jars
        canBeConsumed = false
        canBeResolved = true
        extendsFrom nativeLibraryAndJars
    }

    nativeLibrary { // dll with slf4j jars
        canBeConsumed = true
        canBeResolved = false
        extendsFrom nativeLibraryOnly
    }

}

String osName = System.getProperty("os.name").toLowerCase()
String artifactName = "qrng"
String artifactNameWithExt = artifactName
if (osName.contains("windows")) {
    artifactNameWithExt += ".dll"
}
else
if (osName.contains("mac os")) {
    artifactNameWithExt += ".dylib"
}
else {
    artifactNameWithExt += ".so"
}

artifacts {
    nativeLibraryAndJars(nativeCompile.outputDirectory.file(artifactNameWithExt)) {
        builtBy nativeCompile
    }
}



dependencies {
    //implementation group: 'org.ajoberstar.grgit', name: 'org.ajoberstar.grgit.gradle.plugin', version: '5.2.1'

    // Warning: do not use log4j < 2.16 because if a serious (10 of 10 points) vulnerability!
    implementation 'org.slf4j:slf4j-api:2.+'
    implementation 'org.slf4j:slf4j-simple:2.+'

    // cactoos (for pure OOP)
    implementation 'org.cactoos:cactoos:0.+'

//    implementation 'org.java-websocket:Java-WebSocket:1.5.3' -> embedded into src/java/main
    compileOnly 'org.graalvm.buildtools:native-gradle-plugin:0.9.19'
}

// Excluding all jars from the nativeLibrary configuration.
configurations.nativeLibraryAndJars.forEach {
    if (it.name.endsWith(".jar")) {
        def nameAndVersion = it.name.substring(0,it.name.length()-4)
        configurations.nativeLibrary.exclude module: nameAndVersion
        def i = nameAndVersion.lastIndexOf('-')
        while (i>0) {
            // at least one symbol for name prior to possible version
            nameAndVersion = nameAndVersion.substring(0,i)
            configurations.nativeLibrary.exclude module: nameAndVersion
            i = nameAndVersion.lastIndexOf('-')
        }
    }
}


test {
    failFast = true
    // use the task testNative to build and run a test program, which uses the native library
}

tasks.withType(Test) {
    // adding the dir containing native lib to java.library.path (for testing)
    systemProperty "java.library.path", project.buildDir.absolutePath + '/native/nativeCompile'
}

task testNative {
//    dependsOn nativeCompile
    doLast {
    if (osName.contains("windows")) {
        def libFile = project.buildDir.absolutePath + '/native/nativeCompile/' + artifactName + '.lib'
        exec {
                commandLine 'clang',
                        '-I'+project.buildDir.absolutePath + '/native/nativeCompile/',
                        '-L'+project.buildDir.absolutePath + '/native/nativeCompile/',
                        '-Wall',
                        '-l'+artifactName,
                        '-lpthread',
                        '-o', project.buildDir.absolutePath + '/native/nativeCompile/test.exe',
                        'src/test/cpp/test.cpp',
                libFile
        }
    }
    else
    {
        exec {
                commandLine 'c++',
                        '-I'+project.buildDir.absolutePath + '/native/nativeCompile/',
                        '-L'+project.buildDir.absolutePath + '/native/nativeCompile/',
                        '-Wall',
                        '-o', project.buildDir.absolutePath + '/native/nativeCompile/test.exe',
                        '-Wl,-rpath,.,-rpath,/Users/sergejs/.sdkman/candidates/java/current/lib,-rpath,/Users/sergejs/.sdkman/candidates/java/current/bin/lib/server',
                        'src/test/cpp/test.cpp',
                        '-l'+artifactName // -l options must be in the end (for some c++ versions)
         }
    }
        if (osName.contains("mac os")) {
            exec {
                commandLine 'install_name_tool',
                        '-change',
                        project.buildDir.absolutePath + '/native/nativeCompile/'+artifactNameWithExt,
                        '@loader_path/'+artifactNameWithExt,
                        project.buildDir.absolutePath + '/native/nativeCompile/test.exe'
            }
        }
        exec {
             workingDir project.buildDir.absolutePath+'/native/nativeCompile/'
//             environment DYLD_LIBRARY_PATH: project.buildDir.absolutePath+'/native/nativeCompile/:'+project.buildDir.absolutePath+'../.libs:'+'$System.env.JAVA_HOME'+'/lib:'+'$System.env.JAVA_HOME'+'/lib/server'
//             ^^^ needed, if liboqs is used for KEM and signatures; not needed, if pure-Java BouncyCastle KEM and signatures are used
             commandLine project.buildDir.absolutePath+'/native/nativeCompile/test.exe'
        }
    }
}

// used by nativeCompile and, thus, by nativeLibrary
graalvmNative {
    binaries {
        main {
            imageName = artifactName // The name of the native image, defaults to the project name
//            debug = true // Determines if debug info should be generated, defaults to false
            verbose = true // Add verbose output, defaults to false
            fallback = false // Sets the fallback mode of native-image, defaults to false
            sharedLibrary = true // Determines if image is a shared library, defaults to false if `java-library` plugin isn't included
            buildArgs.add('--no-server')
            buildArgs.add('--enable-http')
            buildArgs.add('--enable-https')
            buildArgs.add('-H:Optimize=0')
            //buildArgs.add('--enable-url-protocols')
            buildArgs.add('-H:+AllowVMInspection')
            buildArgs.add('-H:EnableURLProtocols=http,https,ws,wss')
            buildArgs.add('-H:+EnableSignalAPI')
            buildArgs.add('--configure-reflection-metadata')
            buildArgs.add('--enable-all-security-services')
            buildArgs.add('-H:ReflectionConfigurationFiles='+project.buildDir.absolutePath+'/../reflection.json')
            buildArgs.add('-H:JNIConfigurationFiles='+project.buildDir.absolutePath+'/../jni.json')
            buildArgs.add('-cp')
            buildArgs.add(String.join(File.pathSeparator,configurations.compileClasspath.files.collect { "$it.name" }))
        }
    }
}

nativeCompile {
    doLast {
        if (!osName.contains("windows")) {
            // creating the corresponding lib* file that is needed for c++ "-l" option to find the library when linking
            copy {
                from project.buildDir.absolutePath + '/native/nativeCompile/' + artifactNameWithExt
                into project.buildDir.absolutePath + '/native/nativeCompile'
                rename '(.*)', 'lib$1'
            }
        }
    }
}

